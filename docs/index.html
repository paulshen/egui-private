<!DOCTYPE html>
<html>
<head>
    <title>Rust GUI - code render</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="twitter:card" content="summary" />
    <meta name="og:title" content="Rust GUI - code render" />
    <meta name="og:description" content="experiments building UIs with Rust">

    <style>
        html {
            /* Remove touch delay: */
            touch-action: manipulation;
        }

        html,
        body {
            background-color: #2b303b;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        #container {
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>

<body>
    <div id="container">
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // The `--no-modules`-generated JS from `wasm-bindgen` attempts to use
        // `WebAssembly.instantiateStreaming` to instantiate the wasm module,
        // but this doesn't work with `file://` urls. This example is frequently
        // viewed by simply opening `index.html` in a browser (with a `file://`
        // url), so it would fail if we were to call this function!
        //
        // Work around this for now by deleting the function to ensure that the
        // `no_modules.js` script doesn't have access to it. You won't need this
        // hack when deploying over HTTP.
        delete WebAssembly.instantiateStreaming;

        const pendingCalls = [];
        window.rust_callback = v => {
            pendingCalls.push(v);
        };
        function set_callback(f) {
            window.rust_callback = v => f(JSON.stringify(v));
            pendingCalls.forEach(pendingCall => window.rust_callback(pendingCall));
        }
        async function make_call(query) {
            switch (query.kind) {
                case 'quickInfo': {
                    const [filename, offsetString] = query.value.split('$');
                    const offset = parseInt(offsetString);
                    const w = await monaco.languages.typescript.getTypeScriptWorker();
                    const worker = await w();
                    const quickInfo = await worker.getQuickInfoAtPosition(filename, offset);
                    if (quickInfo === undefined) {
                        return;
                    }
                    window.rust_callback({
                        kind: "quickInfo",
                        value: JSON.stringify(quickInfo),
                    });
                    break;
                }
                case 'goToDefinition': {
                    const [filename, offsetString] = query.value.split('$');
                    const offset = parseInt(offsetString);
                    const w = await monaco.languages.typescript.getTypeScriptWorker();
                    const worker = await w();
                    const definitions = await worker.getDefinitionAtPosition(filename, offset);
                    if (definitions === undefined) {
                        return;
                    }
                    const definition = definitions[0];
                    if (definition === undefined) {
                        return;
                    }
                    window.rust_callback({
                        kind: 'fileContents',
                        value: JSON.stringify({
                            filename: definition.fileName,
                            offset: definition.textSpan.start,
                            contents: monaco.editor.getModel(definition.fileName).getValue(),
                        }),
                    });
                    break;
                }
            }
        }
    </script>

    <!-- this is the JS generated by the `wasm-bindgen` CLI tool -->
    <script src="my_app.js"></script>

    <script>
        // We'll defer our execution until the wasm is ready to go.
        // Here we tell bindgen the path to the wasm file so it can start
        // initialization and return to us a promise when it's done.
        wasm_bindgen("./my_app_bg.wasm")
            .then(on_wasm_loaded)["catch"](console.error);

        function on_wasm_loaded() {
            wasm_bindgen.start("canvas");
        }
    </script>

    <script src="app.bundle.js"></script>
    <script type="application/javascript" src="react.js"></script>
    <script type="application/javascript">
        window.REACT_SOURCE.forEach(({path, content}) => {
            monaco.editor.createModel(content, 'typescript', `file:///${path}`);
        });
        window.rust_callback({
            kind: 'fileContents',
            value: JSON.stringify({
                filename: 'file:///react-reconciler/src/ReactFiberReconciler.new.js',
                contents: monaco.editor.getModel('file:///react-reconciler/src/ReactFiberReconciler.new.js').getValue(),
            }),
        });
    </script>
</body>

</html>

<!-- Powered by egui: https://github.com/emilk/egui/ -->
